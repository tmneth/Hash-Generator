## Step-by-step hash of “hello world”

For simplicity, all values are converted to binary

### Step 1 - Initialize semi-random 8-bit keys

- Seed the pseudo-random number generator with string length `(11 in this example)`
- Generate 8 8-bit keys

```
10111111 10010110 01110101 00001101 00101011 01100111 11101001 00011001
```

### Step 2 - Pre-processing

- Convert “hello world” to binary

```
01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 
```

- Pad with 10000000’s until data is a multiple of 512, less 64 bits (448 bits in our case)

```
01101000     01100101     01101100     01101100
01101111     00100000     01110111     01101111
01110010     01101100     01100100     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
```

- Append 64 bits to the end, where the 64 bits are pseudo-random keys

```
01101000     01100101     01101100     01101100
01101111     00100000     01110111     01101111
01110010     01101100     01100100     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10000000     10000000     10000000     10000000
10111111     10010110     01110101     00001101
00101011     01100111     11101001     00011001
```

Now we have our input, which will always be evenly divisible by 512

### Step 3 - Compress to 16 32-bit words

Every 512-bit “chunk” of data will be compressed to 16 32-bit "words". In our case, because “hello world” is
so short, we only have one chunk. At each iteration of the loop, we will xor new words with existing ones

```
01101000011001010110110001101100
01101111001000000111011101101111
01110010011011000110010010000000
10000000100000001000000010000000
10000000100000001000000010000000
10000000100000001000000010000000
10000000100000001000000010000000
10000000100000001000000010000000
10000000100000001000000010000000
10000000100000001000000010000000
10000000100000001000000010000000
10000000100000001000000010000000
10000000100000001000000010000000
10000000100000001000000010000000
10111111100101100111010100001101
00101011011001111110100100011001
```

### Step 4 - Mutate the words

- Every single word is added to another
- Every term is being shifted to the right by 2 bits

```
For i from w[0…16]:
    For j from w[0…16]:
        w[i] += w[j] >> 2
```

```
01010111000000101111011101101011
01011110110101011001010010100100
01100011111111000010001001001100
01110100101100111110111111100100
01111001000011000000101010111011
00111110101111111010110111110101
00110010001110110111010000110001
00100001110011011110100001100000
00001100001111100010000011011110
11101111111100010110101100000011
00011010110011001011110001010011
00000011000011001001011100001100
11100011111000000110011000100000
00001010111101100110010111101010
00101101010110010011101000101111
01110111011100001111001100100110
```

### Step 5 - Reduce to 8 32-bit words
```
For i from w[0…8] and For j from w[8…0]:
    h[i] = (w[i] + w[j]) << 2
```
```       
For i from w[4…8]:
    h[i] += h[i-4] + (h[i-3] or h[i-2]) + h[i-1]
``` 
```
For i from w[0…4]:
    h[i] += h[i+1] xor h[i+3] >> (input.size() % 2) 
```
```
00111001110011111010101001000100
00110000101110110011101101001100
10111011110010100010000011011000
01100010010100010101100000010000
11110000011000101000011100011100
01100110001100011010100100100000
10001000101100110111110011010000
10111000001100000010010011111000
```

### Step 6 - Modify final values
```
00111001110011111010101001000100 = 3b634188
00110000101110110011101101001100 = d0b07dca
10111011110010100010000011011000 = cbbcea30
01100010010100010101100000010000 = 6fade396
11110000011000101000011100011100 = 487ec54c
01100110001100011010100100100000 = db472290
10001000101100110111110011010000 = 8a449d94
10111000001100000010010011111000 = 80460278
```

### Step 7 - Concatenate final hash

```
3b634188d0b07dcacbbcea306fade396487ec54cdb4722908a449d9480460278
```